# 스택# # Array를 이용한 스택# class ArrayStack:#     def __init__(self):#         self.data = []##     def size(self):#         return len(self.data)##     def isEmpty(self):#         return self.size() == 0##     def push(self, item):#         self.data.append(item)##     def pop(self):#         return self.data.pop()##     def peek(self):#         return self.data[-1]### def solution(expr):#     match = {#         ')': '(',#         '}': '{',#         ']': '[',#     }#     S = ArrayStack()#     for c in expr:#         if c in '({[':#             S.push(c)#         elif c in match:#             if S.isEmpty():#                 return False#             else:#                 t = S.pop()#                 if t != match[c]:#                     return False##     return S.isEmpty()### if __name__ == "__main__":#     s = ArrayStack()##     s.push(1)#     s.push(2)#     s.push(3)#     s.push(4)##     print(s.size())#     print(s.peek())#     print(s.isEmpty())#     print(s.data)#     s.pop()#     print(s.data)# 연습문제"""올바른 수식(A+B){(A+B)*C}[(A+B)*(C+D)]알고리즘 설계 - 수식을 왼쪽부터 한 글자씩 읽어서여는 괄호 - ( or { or [ -를 만나면 스택에 push닫는 괄호 - ) or } or ] -를 만나면 스택이 비어 있으면 올바르지 않은 수식 - 스택에서 pop 쌍을 이루는 여는 괄호인지 검사   - 맞지 않으면 올바르지 않은 수식 - 끝까지 검사한 후, 스택이 비어 있어야 올바른 수식"""# class ArrayStack:#     def __init__(self):#         self.data = []##     def size(self):#         return len(self.data)##     def isEmpty(self):  # size 메서드를 이용해서 스택이 비어있는지 판단할 수 있음#         return self.size() == 0##     def push(self, item):#         self.data.append(item)##     def pop(self):  # 맨 끝에 있는 원소 제거#         return self.data.pop()##     def peek(self):  # 맨 끝에 있는 원소를 보여준다.#         return self.data[-1]### if __name__ == "__main__":#     s = ArrayStack()#     s.push(1)#     s.push(2)#     s.push(3)#     s.push(5)##     print(s.data)#     print(s.size())#     print(s.isEmpty())#     print(s.peek())# Double Linked List 로 인한 Stack# class Node:#     def __init__(self, item):#         self.data = item#         self.next = None#         self.prev = None### class DoubleLinkedList:#     def __init__(self):#         self.head = Node(None)#         self.tail = Node(None)#         self.head.prev = None#         self.head.next = self.tail#         self.tail.prev = self.head#         self.tail.next = None#         self.count = 0##     # n번째#     def get(self, pos):#         if pos < 0 or pos > self.count:#             return None##         if pos > self.count // 2:#             i = 0#             curr = self.tail#             while i < self.count - pos + 1:#                 curr = curr.prev#                 i += 1#         else:#             i = 0#             curr = self.head#             while i < pos:#                 curr = curr.next#                 i += 1#         return curr##     # 순방향#     def traverse(self):#         answer = []##         curr = self.head##         while curr.next.next:#             curr = curr.next#             answer.append(curr.data)#         return answer##     # 역방향#     def reverse(self):#         answer = []#         curr = self.tail#         while curr.prev.prev:#             curr = curr.prev#             answer.append(curr.data)##         return answer##     def insertAt(self, pos, newnode):#         if pos < 0 or pos > self.count + 1:#             return False##         prev = self.get(pos - 1)#         return self.insertAfter(prev, newnode)##     def insertAfter(self, prev, newnode):#         next = prev.next#         newnode.prev = prev#         newnode.next = next#         prev.next = newnode#         next.prev = newnode#         self.count += 1##         return True##     def popAt(self, pos):#         if pos < 0 or pos > self.count:#             raise IndexError##         prev = self.get(pos - 1)#         return self.popAfter(prev)##     def popAfter(self, prev):#         curr = prev.next#         prev.next = curr.next#         curr.next.prev = prev#         self.count -= 1#         return curr.data### class LinkedListStack:#     def __init__(self):#         self.data = DoubleLinkedList()##     def size(self):#         return self.data.count##     def isEmpty(self):#         return self.size() == 0##     def push(self, item):#         node = Node(item)#         self.data.insertAt(self.size() + 1, node)##     def pop(self):#         return self.data.popAt(self.size())#         # 현재 size에서 제일 위에 있는걸 삭제 해야하기 때문에 count를 그대로 가져다 쓰면 됨##     def peek(self):#         return self.data.get(self.size()).data### if __name__ == "__main__":#     L = LinkedListStack()#     L.push(11)#     L.push(22)#     L.push(33)#     L.push(55)##     print(L.data.traverse())#     print(L.size())#     print(L.peek())#     print(L.isEmpty())#     L.pop()#     print(L.size())#     print(L.data.traverse())## single Linked List Stackclass Node:    def __init__(self, item):        self.data = item        self.next = Noneclass LinkedList:    def __init__(self):        self.head = Node(None)        self.tail = None        self.head.next = self.tail        self.count = 0    def get(self, pos):        if pos < 0 or pos > self.count:            raise IndexError        i = 0        curr = self.head        while i < pos:            curr = curr.next            i += 1        return curr    def traverse(self):        answer = []        curr = self.head        while curr.next:            curr = curr.next            answer.append(curr.data)        return answer    def addAt(self, pos, newnode):        if pos < 0 or pos > self.count + 1:            return False        # 조건문 조심하기        if pos != 1 and pos == self.count + 1:            prev = self.tail        else:            prev = self.get(pos - 1)        return self.addAfter(prev, newnode)    def addAfter(self, prev, newnode):        newnode.next = prev.next        if prev.next is None:            self.tail = newnode        prev.next = newnode        self.count += 1        return True    def popAt(self, pos):        if pos < 0 or pos > self.count:            raise IndexError        prev = self.get(pos - 1)        return self.popAfter(prev)    def popAfter(self, prev):        if prev.next == None:            return None        curr = prev.next        prev.next = curr.next        self.count -= 1        return curr.dataclass LinkedListStack:    def __init__(self):        self.data = LinkedList()    def size(self):        return self.data.count    def isEmpty(self):        return self.size() == 0    def push(self, item):        node = Node(item)        self.data.addAt(self.size() + 1, node)    def pop(self):        return self.data.popAt(self.size())    def peek(self):        return self.data.get(self.size()).dataif __name__ == "__main__":    s = LinkedListStack()    s.push(11)    s.push(22)    s.push(44)    print(s.data.traverse())    s.pop()    print(s.data.traverse())    print(s.size())    print(s.isEmpty())    print(s.peek())