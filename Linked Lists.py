# # 연결리스트# """#  ========================#  연산 정의#  1. 특정 원소 참조#  2. 리스트 순회#  3. 길이 얻어내기#  4. 원소 삽입#  5. 원소 삭제#  6. 두 리스트 합치기##  * 첫 노드는 1부터 시작한다.#  ========================#  연결리스트 원소 삽입의 복잡도#  - 맨 앞에 삽입하는 경우 : O(1)#  - 중간에 삽입하는 경우 : O(n)#  - 맨 끝에 삽입하는 경우 : O(1)# """### class Node:##     def __init__(self, item):#         self.data = item#         self.next = None### class LinkedList:##     def __init__(self):#         self.nodeCount = 0#         self.head = None#         self.tail = None##     def getAt(self, pos):#         if pos < 1 or pos > self.nodeCount:#             return None##         i = 1#         curr = self.head#         while i < pos:#             curr = curr.next#             i += 1##         return curr##     def insertAt(self, pos, newNode):#         if pos < 1 or pos > self.nodeCount + 1:#             return False##         if pos == 1:#             newNode.next = self.head#             self.head = newNode##         else:#             if pos == self.nodeCount + 1:#                 prev = self.tail#             else:#                 prev = self.getAt(pos - 1)#             newNode.next = prev.next#             prev.next = newNode##         if pos == self.nodeCount + 1:#             self.tail = newNode##         self.nodeCount += 1#         return True##     def popAt(self, pos):#         if pos < 1 or pos > self.nodeCount:#             return False##     def traverse(self):#         result = []#         curr = self.head#         while curr != None:#             result.append(curr.data)#             curr = curr.next#         return result### if __name__ == "__main__":#     node1 = Node(12)#     node2 = Node(34)#     node3 = Node(50)#     l = LinkedList()#     l.insertAt(1, node1)#     l.insertAt(2, node2)#     l.insertAt(3, node3)##     print(l.traverse())#     print(l.popAt(2))#     print(l.traverse())#     print(l.insertAt(2, Node(30)))#     print(l.traverse())###### 유튭 강의# class Node:#     def __init__(self, data=None):#         self.data = data#         self.next = None### class linked_list:#     def __init__(self):#         self.head = Node()##     def append(self, data):#         new_node = Node(data)#         cur = self.head##         while cur.next != None:#             cur = cur.next#         cur.next = new_node##     def length(self):#         cur = self.head#         total = 0#         while cur.next != None:#             total += 1#             cur = cur.next##         return total##     def display(self):#         elems = []#         cur_node = self.head#         while cur_node.next != None:#             elems.append(cur_node.data) # 첫번째 칸을 None으로 남겨둬야 하나?#             cur_node = cur_node.next#         print(elems)##     def get(self, index):#         if index >= self.length():#             print("Error: 'GET' Index out if range!")#             return None#         cur_idx = 0#         cur_node = self.head#         while True:#             cur_node = cur_node.next#             if cur_idx == index:#                 return cur_node.data#             cur_idx += 1##     def erase(self, index):#         if index >= self.length():#             print("Error: 'Erase' Index out of range!")#             return#         cur_idx = 0#         cur_node = self.head#         while True:#             last_node = cur_node#             cur_node = cur_node.next#             if cur_idx == index:#                 last_node.next = cur_node.next#                 return#             cur_idx += 1### if __name__ == '__main__':#     mylist = linked_list()##     mylist.append(1)#     mylist.append(2)#     mylist.append(3)#     mylist.append(4)##     mylist.display()#     print("element at 2nd index : {0}".format(mylist.get(3)))##     mylist.erase(0)#     mylist.display()class Node:    def __init__(self, data=None):        self.data = data        self.next = Noneclass LinkedList:    def __init__(self):        self.head = Node()    def length(self):        """        ※ 연결리스트의 길이 찾기        1. self.head와 count를 setting 해준다.        2. curr.next가 None이 될때까지 count를 +1씩 더해준다.        3. curr.next가 None이 되면 마지막 count를 return 해준다.        :return: length인 만큼 갯수만 return 해준다.        """        curr = self.head        count = 0        while curr.next != None:            count += 1            curr = curr.next        return count    def get(self, node_index):        """        ※ 연결리스트의 원하는 index의 값을 찾기        1. 내가 입력한 node_index가 self.length보다 큰가? (당연히 작으면 안되므로 None을 반환 해준다.)        2. index값과 self.head를 선언 해준다.        3. index와 length의 길이를 비교하여 반복하며, 반복중에 index와 내가 정한 node_index가 같으면 그 data값을 return 한다.        :param node: 직접 뽑아낼 node_index를 고른다.        참고 사항 : 그 노드 갯수보다 크거나 노드가 하나이면 None 뽑아내기            -> 하나이면 None이기 때문에        :return: 찾아낼 수를 정하고 return        """        if node_index >= self.length():            print("Error not node!!")            return None        index = 1        curr = self.head        while index < self.length():            curr = curr.next            if index == node_index:                return curr.data            index += 1    def insert(self, data):        """        1. 앞서 작성한 class Node에 insert할 data값을 넣는다.        2. 마찬가지로 self.head를 선언해준다.        3. next가 None이 나올때까지 반복시켜준다.        :param data: 넣을 node값        :return: insert할 수 있는지 없는지 True/False로 표시        """        new_node = Node(data)        curr = self.head        while curr.next != None:            curr = curr.next        curr.next = new_node    def pop(self, node_index):        """        연결리스트 삭제        원하는 node_index를 입력        1) index가 length보다 큰지 작은지 비교 node_index가 크면 Error 출력        2) head와 index를 선언        3) while문으로 반복하며 prev-1 / prev / prev+1의 값들을 선언        4) node_index와 index가 같으면 prev-1.next -> prev+1 이동된다.        :param node_index:        :return:        """        if node_index > self.length():            print("Error 'pop' index None")            return        f_curr = self.head        index = 0        while True:            s_curr = f_curr            t_curr = s_curr.next            if node_index == index:                s_curr.next = t_curr.next                return t_curr.data            index += 1    def display(self):        """        본인이 넣은 데이터를 list화 해서 볼 수 있게 작성한다.        1. 빈 list를 만들어준다.        2. self.head를 선언해준다.        3. next가 None이 될때까지 list에 append(추가) 해준다. None이 되면 저장된 res의 list값을 return 해준다.        :return: list로 저장된 값        """        res = []        curr = self.head        while curr.next != None:            curr = curr.next            res.append(curr.data)        return resif __name__ == "__main__":    L = LinkedList()    L.insert(11)    L.insert(22)    L.insert(33)    print(L.display())    # print(L.get(1))    print("POP : ", L.pop(1))    print(L.display())